<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC BitTorrent Tracker Signaling Demo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #f0f2f5;
            font-size: 16px;
        }
        .container {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            margin-bottom: 25px;
        }
        .logs-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 25px;
            min-width: 0;
        }
        .logs-container .container {
            min-width: 0;
            overflow: hidden;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            margin: 8px;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        button:hover {
            background: #0056b3;
            transform: translateY(-1px);
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
/* Add this new class for enabled state that overrides disabled styling */
button.force-enabled {
    background: #28a745 !important;
    cursor: pointer !important;
    transform: scale(1.02) !important;
    opacity: 1 !important;
}

/* Or alternatively, be more specific with the send button */
#sendBtn:not(.actually-disabled) {
    background: #28a745 !important;
    cursor: pointer !important;
    transform: scale(1.02) !important;
}

        .log {
            background: #1a1a1a;
            color: #00ff00;
            padding: 20px;
            border-radius: 8px;
            height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
            word-break: break-all;
            border: 2px solid #333;
            box-sizing: border-box;
        }
        .json-log {
            background: #001122;
            color: #00ff88;
            padding: 20px;
            border-radius: 8px;
            height: 500px;
            overflow-y: auto;
            overflow-x: hidden;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
            word-break: break-all;
            border: 2px solid #333;
            box-sizing: border-box;
        }
        .json-log.sent {
            background: #220011;
            color: #ff8800;
            border-color: #ff4400;
        }
        .json-log.received {
            background: #001122;
            color: #00ff88;
            border-color: #00aa44;
        }
        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: bold;
            font-size: 18px;
        }
        .status.connected {
            background: #d4edda;
            color: #155724;
            border: 2px solid #c3e6cb;
        }
        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 2px solid #f5c6cb;
        }
        .status.connecting {
            background: #fff3cd;
            color: #856404;
            border: 2px solid #ffeaa7;
        }
        input[type="text"] {
            width: 350px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            margin: 8px;
            font-size: 16px;
        }
        select {
            width: 374px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            margin: 8px;
            font-size: 16px;
        }
        .peer-info {
            background: #e9ecef;
            padding: 15px;
            border-radius: 8px;
            margin: 8px 0;
            font-size: 16px;
            border: 1px solid #dee2e6;
        }
        h1 {
            font-size: 28px;
            color: #333;
            margin-bottom: 10px;
        }
        h3 {
            font-size: 20px;
            color: #444;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        label {
            font-size: 16px;
            font-weight: 500;
            color: #555;
        }
        p {
            font-size: 16px;
            color: #666;
            line-height: 1.5;
        }
        .log-header {
            background: #333;
            color: white;
            padding: 10px 20px;
            border-radius: 8px 8px 0 0;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 0;
        }
        .log-header.sent {
            background: #cc3300;
        }
        .log-header.received {
            background: #006633;
        }
        .controls-section {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî• WebRTC BitTorrent Tracker Signaling Demo</h1>
        <p>This demo shows how to use BitTorrent trackers for WebRTC peer discovery and signaling.</p>
        
        <div class="status" id="status">Disconnected</div>
        
        <div class="controls-section">
            <div>
                <label>Tracker URL:</label>
                <select id="trackerUrl">
                    <option value="wss://tracker.openwebtorrent.com">wss://tracker.openwebtorrent.com</option>
                    <option value="wss://tracker.files.fm:7073">wss://tracker.files.fm:7073</option>
                    <option value="wss://tracker.webtorrent.dev">wss://tracker.webtorrent.dev</option>
                </select>
            </div>
        </div>
        
        <div class="controls-section">
            <div>
                <label>Info Hash (room):</label>
                <input type="text" id="infoHash" value="01234567890123456789" maxlength="20" />
                <button onclick="generateNewRoom()">Generate New Room</button>
            </div>
        </div>
        
        <div class="peer-info">
            <strong>Your Peer ID:</strong> <span id="peerIdDisplay"></span>
        </div>
        
        <div class="controls-section">
            <button onclick="connectToTracker()" id="connectBtn">Connect to Tracker</button>
            <button onclick="joinRoom()" id="joinBtn" disabled>Join Room</button>
            <button onclick="createOffer()" id="offerBtn" disabled>Create WebRTC Offer</button>
            <button onclick="sendMessage()" id="sendBtn">Send Test Message</button>
            <button onclick="disconnect()" id="disconnectBtn" disabled>Disconnect</button>
            <button onclick="disconnectWebSocket()" id="disconnectWSBtn" disabled>Disconnect WebSocket Only</button>
            <button onclick="checkConnections()" id="checkConnectionsBtn">Check Connections</button>
        </div>
        
        <div class="controls-section">
            <div>
                <label>Test Message:</label>
                <input type="text" id="testMessage" value="Hello from WebRTC!" />
            </div>
        </div>
    </div>

    <div class="container">
        <h3>üìä Peers in Room</h3>
        <div id="peersList">No peers found</div>
    </div>

    <div class="logs-container">
        <div class="container">
            <div class="log-header sent">üì§ Outgoing Messages (JSON)</div>
            <div class="json-log sent" id="jsonOutputSent"></div>
        </div>
        
        <div class="container">
            <div class="log-header received">üì• Incoming Messages (JSON)</div>
            <div class="json-log received" id="jsonOutputReceived"></div>
        </div>
    </div>

    <div class="container">
        <h3>üìù General Log</h3>
        <div class="log" id="logOutput"></div>
    </div>

    <script>
        // WebRTC Signaling via BitTorrent Tracker Implementation
        class WebRTCTrackerSignaling {
            constructor(trackerUrl) {
                this.trackerUrl = trackerUrl;
                this.socket = null;
                this.peerId = this.generateSimplePeerId();
                this.infoHash = null;
                this.peerConnections = new Map();
                this.dataChannels = new Map();
                this.connectedPeers = new Set();
                this.announceInterval = null;
                this.onPeerConnected = null;
                this.onPeerDisconnected = null;
                this.onMessageReceived = null;
                this.onStatusChanged = null;
                
                // Store pending ICE candidates for each connection
                this.pendingIceCandidates = new Map();
            }

            generateSimplePeerId() {
                const digits = '0123456789';
                return Array.from({ length: 20 }, () => digits[Math.floor(Math.random() * digits.length)]).join('');
            }

            generateSimpleInfoHash() {
                const digits = '0123456789';
                return Array.from({ length: 20 }, () => digits[Math.floor(Math.random() * digits.length)]).join('');
            }

            stringToBuffer(str) {
                return str; // The tracker expects the raw string, not converted
            }

            log(message) {
                console.log(message);
                const logElement = document.getElementById('logOutput');
                if (logElement) {
                    logElement.innerHTML += new Date().toLocaleTimeString() + ': ' + message + '\n';
                    logElement.scrollTop = logElement.scrollHeight;
                }
            }

            logJson(direction, message) {
                const elementId = direction === 'SENDING' ? 'jsonOutputSent' : 'jsonOutputReceived';
                const jsonElement = document.getElementById(elementId);
                if (jsonElement) {
                    const timestamp = new Date().toLocaleTimeString();
                    const formatted = JSON.stringify(message, null, 2)
                        .replace(/("sdp":\s*"[^"]*")/g, (match) => {
                            return match.replace(/\\r\\n/g, '\\r\\n\n    ');
                        });
                    
                    const logEntry = `\n[${timestamp}] ${direction}:\n${formatted}\n${'='.repeat(60)}\n`;
                    jsonElement.innerHTML += logEntry;
                    jsonElement.scrollTop = jsonElement.scrollHeight;
                }
            }

            async connect() {
                return new Promise((resolve, reject) => {
                    this.log('Connecting to tracker: ' + this.trackerUrl);
                    this.socket = new WebSocket(this.trackerUrl);
                    
                    this.socket.onopen = () => {
                        this.log('‚úÖ Connected to tracker');
                        this.onStatusChanged?.('connected');
                        resolve();
                    };

                    this.socket.onerror = (error) => {
                        this.log('‚ùå WebSocket error: ' + error);
                        reject(error);
                    };

                    this.socket.onmessage = (event) => {
                        try {
                
                            const message = JSON.parse(event.data);
                            this.logJson('RECEIVED', message);
                            this.handleTrackerMessage(message);
                        } catch (e) {
                            this.log('‚ùå Failed to parse message: ' + event.data);
                        }
                    };

                    this.socket.onclose = (event) => {
                        this.log('üîå Disconnected from tracker. Code: ' + event.code + ', Reason: ' + event.reason);
                        this.onStatusChanged?.('disconnected');
                        if (this.announceInterval) {
                            clearInterval(this.announceInterval);
                            this.announceInterval = null;
                        }
                    };
                });
            }

            sendMessage(message) {
                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                    this.logJson('SENDING', message);
                    this.socket.send(JSON.stringify(message));
                } else {
                    this.log('‚ùå Cannot send message - socket not connected');
                }
            }

            announceToSwarm(infoHash) {
                this.infoHash = infoHash;
                
                const announceMessage = {
                    action: 'announce',
                    info_hash: this.stringToBuffer(infoHash),
                    peer_id: this.stringToBuffer(this.peerId),
                    port: 6881,
                    uploaded: 0,
                    downloaded: 0,
                    left: 0,
                    event: 'started',
                    numwant: 50,
                    compact: 0
                };

                this.log('üì¢ Announcing to swarm: ' + infoHash);
                this.sendMessage(announceMessage);
            }

            startPeriodicAnnounce(interval = 120000) {
                if (this.announceInterval) {
                    clearInterval(this.announceInterval);
                }
                
                this.announceInterval = setInterval(() => {
                    if (this.socket && this.socket.readyState === WebSocket.OPEN && this.infoHash) {
                        const announceMessage = {
                            action: 'announce',
                            info_hash: this.stringToBuffer(this.infoHash),
                            peer_id: this.stringToBuffer(this.peerId),
                            port: 6881,
                            uploaded: 0,
                            downloaded: 0,
                            left: 0,
                            event: 'update',
                            numwant: 50,
                            compact: 0
                        };
                        this.sendMessage(announceMessage);
                        this.log('üîÑ Periodic announce sent');
                    }
                }, interval);
            }

            checkP2PConnections() {
                let connectedCount = 0;
                this.peerConnections.forEach((pc, peerId) => {
                    if (pc.connectionState === 'connected') {
                        connectedCount++;
                        this.log(`‚úÖ P2P Connected to: ${peerId}`);
                    }
                });
                
                this.log(`üìä Total P2P connections: ${connectedCount}`);
                return connectedCount;
            }

            async createAndSendOffer() {
                this.log('üöÄ Creating WebRTC offer');

                const peerConnection = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });

                const dataChannel = peerConnection.createDataChannel('chat', {
                    ordered: true
                });

                const offerId = this.generateSimplePeerId().substring(0, 10);
                
                // Store the peer connection with offer ID
                this.peerConnections.set(String(offerId), peerConnection);
                this.dataChannels.set(String(offerId), dataChannel);

                dataChannel.onopen = () => {
                    this.log('üì° Data channel opened (offer side)');
                    document.getElementById('sendBtn').disabled = false;
                };

                dataChannel.onmessage = (event) => {
                    this.log('üì® Received: ' + event.data);
                    this.onMessageReceived?.(event.data);
                };

                peerConnection.onconnectionstatechange = () => {
                    this.log(`üîó Connection state changed to: ${peerConnection.connectionState}`);
                    if (peerConnection.connectionState === 'connected') {
                        this.log('üéâ P2P connection established!');
                    }
                };

                peerConnection.oniceconnectionstatechange = () => {
                    this.log(`üßä ICE connection state: ${peerConnection.iceConnectionState}`);
                };

                peerConnection.onicegatheringstatechange = () => {
                    this.log(`üßä ICE gathering state: ${peerConnection.iceGatheringState}`);
                };

    

                try {
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);

                    await this.waitForIceGatheringComplete(peerConnection, 10000);


                    this.log('üì§ Sending offer with ID: ' + offerId);
                    this.log('üßæ ICE candidates are now embedded in SDP');
                    

                    // Send offer through tracker
                    const offerMessage = {
                        action: 'announce',
                        info_hash: this.stringToBuffer(this.infoHash),
                        peer_id: this.stringToBuffer(this.peerId),
                        port: 6881,
                        uploaded: 0,
                        downloaded: 0,
                        left: 0,
                        event: 'update',
                        numwant: 0,
                        compact: 0,
                        offers: [{
                            offer: {
                                type: 'offer',
                                sdp: peerConnection.localDescription.sdp
                            },
                            offer_id: offerId
                        }]
                    };

                    this.sendMessage(offerMessage);
                } catch (error) {
                    this.log('‚ùå Error creating offer: ' + error);
                }
            }
            waitForIceGatheringComplete(peerConnection, timeoutMs = 10000) {
                return new Promise((resolve) => {
                    // If already complete, resolve immediately
                    if (peerConnection.iceGatheringState === 'complete') {
                        this.log('üßæ ICE gathering already complete');
                        resolve();
                        return;
                    }

                    let isResolved = false;
                    let candidateCount = 0;
                    let lastCandidateTime = Date.now();

                    const resolveOnce = (reason) => {
                        if (!isResolved) {
                            isResolved = true;
                            this.log(`üßæ ICE gathering finished: ${reason}`);
                            peerConnection.removeEventListener('icegatheringstatechange', checkState);
                            peerConnection.removeEventListener('icecandidate', candidateHandler);
                            clearTimeout(timeoutHandle);
                            clearTimeout(candidateTimeoutHandle);
                            resolve();
                        }
                    };

                    const checkState = () => {
                        if (peerConnection.iceGatheringState === 'complete') {
                            resolveOnce(`Complete state reached with ${candidateCount} candidates`);
                        } else {
                            this.log(`üßä ICE gathering state: ${peerConnection.iceGatheringState}`);
                        }
                    };

                    const candidateHandler = (event) => {
                        if (event.candidate) {
                            candidateCount++;
                            lastCandidateTime = Date.now();
                            this.log(`üßæ Collected ICE candidate #${candidateCount}: ${event.candidate.candidate.substring(0, 50)}...`);
                        } else {
                            // null candidate indicates end of candidates
                            this.log('üßæ Received end-of-candidates signal');
                            resolveOnce(`End-of-candidates signal received with ${candidateCount} candidates`);
                        }
                    };

                    // Listen for state changes and candidates
                    peerConnection.addEventListener('icegatheringstatechange', checkState);
                    peerConnection.addEventListener('icecandidate', candidateHandler);

                    // Main timeout - absolute maximum wait time
                    const timeoutHandle = setTimeout(() => {
                        if (candidateCount > 0) {
                            this.log(`‚è∞ ICE gathering timeout after ${timeoutMs}ms, but we have ${candidateCount} candidates - proceeding`);
                            resolveOnce(`Timeout with ${candidateCount} candidates (acceptable)`);
                        } else {
                            this.log(`‚è∞ ICE gathering timeout after ${timeoutMs}ms with no candidates - proceeding anyway`);
                            resolveOnce(`Timeout with no candidates (may cause connection issues)`);
                        }
                    }, timeoutMs);

                    // Candidate inactivity timeout - if no new candidates for 3 seconds after getting some
                    let candidateTimeoutHandle;
                    const checkCandidateTimeout = () => {
                        candidateTimeoutHandle = setTimeout(() => {
                            if (candidateCount > 0 && (Date.now() - lastCandidateTime) > 3000) {
                                this.log(`üßæ No new candidates for 3s, assuming gathering complete with ${candidateCount} candidates`);
                                resolveOnce(`Candidate inactivity timeout with ${candidateCount} candidates`);
                            } else if (candidateCount > 0) {
                                // Keep checking if we have candidates but they're still coming
                                checkCandidateTimeout();
                            }
                        }, 3000);
                    };

                    // Start the candidate timeout check after a short delay
                    setTimeout(() => {
                        if (candidateCount > 0 && !isResolved) {
                            checkCandidateTimeout();
                        }
                    }, 1000);

                    this.log(`üßä Waiting for ICE gathering (timeout: ${timeoutMs}ms)...`);
                });
            }

            async handleOffer(message) {
                this.log('üì• Received offer from: ' + message.peer_id);
                
                const peerConnection = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });

                const offerId = message.offer_id;
                
                // Store peer connection with both offer_id and peer_id
                this.peerConnections.set(String(offerId), peerConnection);
                this.peerConnections.set(String(message.peer_id), peerConnection);

                peerConnection.onconnectionstatechange = () => {
                    this.log(`üîó Connection state with ${message.peer_id}: ${peerConnection.connectionState}`);
                    if (peerConnection.connectionState === 'connected') {
                        this.log('üéâ P2P connection established with: ' + message.peer_id);
                    }
                };

                peerConnection.oniceconnectionstatechange = () => {
                    this.log(`üßä ICE connection state with ${message.peer_id}: ${peerConnection.iceConnectionState}`);
                };

    

                // Handle incoming data channel
                peerConnection.ondatachannel = (event) => {
                    const dataChannel = event.channel;
                    this.dataChannels.set(message.peer_id, dataChannel);
                    
                    dataChannel.onopen = () => {
                        this.log('üì° Data channel opened with: ' + message.peer_id);
                        this.connectedPeers.add(message.peer_id);
                        this.onPeerConnected?.(message.peer_id);
                        document.getElementById('sendBtn').disabled = false;
                    };

                    dataChannel.onmessage = (event) => {
                        this.log('üì® Message from ' + message.peer_id + ': ' + event.data);
                        this.onMessageReceived?.(event.data, message.peer_id);
                    };

                    dataChannel.onclose = () => {
                        this.log('üì° Data channel closed with: ' + message.peer_id);
                        this.connectedPeers.delete(message.peer_id);
                        this.onPeerDisconnected?.(message.peer_id);
                    };
                };

                try {
                    const offerData = message.offer;
                    
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(offerData));
                    this.log('‚úÖ Remote offer description set');
                    updateStatus('connected');

                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    await this.waitForIceGatheringComplete(peerConnection, 10000);
                    this.log('‚úÖ Local answer description set');
                    this.log('üßæ Answer ICE candidates are now embedded in SDP');

                    // Send answer through tracker
                    const answerMessage = {
                        action: 'announce',
                        info_hash: this.stringToBuffer(this.infoHash),
                        peer_id: this.stringToBuffer(this.peerId),
                        to_peer_id: this.stringToBuffer(message.peer_id),
                        port: 6881,
                        uploaded: 0,
                        downloaded: 0,
                        left: 0,
                        event: 'update',
                        numwant: 0,
                        compact: 0,
                        answer: {
                            type: 'answer',
                            sdp: peerConnection.localDescription.sdp
                        },
                        offer_id: offerId
                    };

                    this.log(`üì§ Sending answer to: ${message.peer_id}`);
                    this.sendMessage(answerMessage);

                } catch (error) {
                    this.log('‚ùå Error handling offer: ' + error);
                }
            }


            async handleAnswer(message) {
                this.log('üì• Received answer from: ' + message.peer_id);
                
                const peerConnection = this.peerConnections.get(String(message.offer_id));
                if (!peerConnection) {
                    this.log('‚ùå No peer connection found for offer_id: ' + message.offer_id);
                    return;
                }

                try {
                    if (peerConnection.signalingState !== 'have-local-offer') {
                        this.log(`‚ùå Wrong signaling state: ${peerConnection.signalingState}, expected: have-local-offer`);
                        return;
                    }

                    // Set the remote description (answer) which contains all ICE candidates
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(message.answer));
                    this.log('‚úÖ Remote answer description set for: ' + message.peer_id);

                    // Store connection by peer_id for easier lookup
                    this.peerConnections.set(String(message.peer_id), peerConnection);
                    
                    this.log('üéØ WebRTC handshake completed with: ' + message.peer_id);
                    this.log('‚è≥ Waiting for P2P connection to establish...');

                    updateStatus('connected');
                    
                    // The connection should now establish automatically since both sides have complete SDP
                    // The data channel will open via the existing onopen handler in createAndSendOffer()
                    
                } catch (error) {
                    this.log('‚ùå Error handling answer: ' + error);
                }
            }

            handleTrackerMessage(message) {
                this.log('üì® Tracker message type: ' + (message.action || 'unknown'));

                if (message.action === 'announce') {
                    if (message.interval) {
                        this.log('üìä Tracker interval: ' + message.interval + 's');
                        this.startPeriodicAnnounce(message.interval * 1000);
                    }
                    
                    if (message.complete !== undefined || message.incomplete !== undefined) {
                        this.log('üìä Swarm stats - Seeders: ' + (message.complete || 0) + ', Leechers: ' + (message.incomplete || 0));
                    }
                    
                    if (message.peers && Array.isArray(message.peers)) {
                        this.log('üë• Found ' + message.peers.length + ' peers in swarm');
                        this.updatePeersList(message.peers);
                    }
                }

                // Handle WebRTC signaling messages
                if (message.offer) {
                    console.log('------------******');
                    this.handleOffer(message);
                } else if (message.answer) {
                    console.log('------------******000000000000000');
                    this.handleAnswer(message);
                } 
            }

            updatePeersList(peers) {
                const peersList = document.getElementById('peersList');
                if (peersList) {
                    if (peers.length === 0) {
                        peersList.innerHTML = 'No other peers found';
                    } else {
                        peersList.innerHTML = peers.map(peer => {
                            const peerIdDisplay = peer.peer_id ? 
                                (peer.peer_id.length > 8 ? peer.peer_id.substring(0, 8) + '...' : peer.peer_id) 
                                : 'unknown';
                            return `<div class="peer-info">Peer: ${peerIdDisplay} (${peer.ip || 'unknown'}:${peer.port || 'unknown'})</div>`;
                        }).join('');
                    }
                }
            }

            sendMessageToAll(message) {
                let sent = 0;
                this.dataChannels.forEach((channel, peerId) => {
                    if (channel.readyState === 'open') {
                        channel.send(message);
                        sent++;
                    }
                });
                this.log(`üì§ Sent message to ${sent} peers: ${message}`);
                return sent;
            }

            disconnect() {
                this.log('üîå Disconnecting...');
                
                // Clear periodic announce
                if (this.announceInterval) {
                    clearInterval(this.announceInterval);
                    this.announceInterval = null;
                }
                
                // Close all peer connections
                this.peerConnections.forEach((pc) => {
                    pc.close();
                });
                this.peerConnections.clear();
                this.dataChannels.clear();
                this.connectedPeers.clear();

                // Send stopped event
                if (this.socket && this.socket.readyState === WebSocket.OPEN && this.infoHash) {
                    const stopMessage = {
                        action: 'announce',
                        info_hash: this.stringToBuffer(this.infoHash),
                        peer_id: this.stringToBuffer(this.peerId),
                        port: 6881,
                        uploaded: 0,
                        downloaded: 0,
                        left: 0,
                        event: 'stopped',
                        numwant: 0
                    };
                    this.sendMessage(stopMessage);
                }

                if (this.socket) {
                    this.socket.close();
                    this.socket = null;
                }
            }
        
        
            disconnectWebSocket() {
    if (!this.socket) {
        console.log('‚ùå No WebSocket connection to disconnect');
        return;
    }
    
    console.log('üîå Disconnecting WebSocket only - keeping P2P connections');
    
    // Clear the announce interval to stop periodic announcements
    if (this.announceInterval) {
        clearInterval(this.announceInterval);
        this.announceInterval = null;
        console.log('‚èπÔ∏è Stopped periodic announcements');
    }
    
    // Send stopped event before closing (optional - for clean disconnect)
    if (this.socket.readyState === WebSocket.OPEN && this.infoHash) {
        const stopMessage = {
            action: 'announce',
            info_hash: this.stringToBuffer(this.infoHash),
            peer_id: this.stringToBuffer(this.peerId),
            port: 6881,
            uploaded: 0,
            downloaded: 0,
            left: 0,
            event: 'stopped',
            numwant: 0
        };
        this.sendMessage(stopMessage);
        console.log('üì§ Sent stop event to tracker');
    }
    
    // Close only the WebSocket connection
    this.socket.close();
    this.socket = null;
    
    console.log('‚úÖ WebSocket disconnected successfully');
    console.log(`üìä P2P connections still active: ${this.connectedPeers.size}`);
    
    // Log current P2P connection states
    this.connectedPeers.forEach(peerId => {
        const peerConnection = this.peerConnections.get(String(peerId));
        const dataChannel = this.dataChannels.get(String(peerId));
        console.log(`üîó Peer ${peerId}: PC=${peerConnection?.connectionState}, DC=${dataChannel?.readyState}`);
    });
}

        }

        // Global instance
        let signaling = null;

        // UI Functions
        function updateStatus(status) {
            const statusEl = document.getElementById('status');
            const connectBtn = document.getElementById('connectBtn');
            const joinBtn = document.getElementById('joinBtn');
            const offerBtn = document.getElementById('offerBtn');
            const sendBtn = document.getElementById('sendBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const disconnectWSBtn = document.getElementById('disconnectWSBtn');

            statusEl.className = 'status ' + status;
            
            switch (status) {
                case 'connected':
                    statusEl.textContent = '‚úÖ Connected to Tracker';
                    connectBtn.disabled = true;
                    joinBtn.disabled = false;
                    offerBtn.disabled = false;
                    disconnectBtn.disabled = false;
                    disconnectWSBtn.disabled = false;
                    // sendBtn state depends on P2P connections
                    updateSendButtonStateByDataChannels();
                    break;
                    
                case 'websocket-disconnected':
                    statusEl.textContent = 'üîå WebSocket Disconnected (P2P Active)';
                    connectBtn.disabled = false;
                    joinBtn.disabled = true;
                    offerBtn.disabled = true; // Can't create new offers without signaling
                    disconnectBtn.disabled = false;
                    disconnectWSBtn.disabled = true;
                    // sendBtn state depends on P2P connections
                    updateSendButtonStateByDataChannels();
                    break;
                    
                case 'disconnected':
                    statusEl.textContent = '‚ùå Disconnected';
                    connectBtn.disabled = false;
                    joinBtn.disabled = true;
                    offerBtn.disabled = true;
                    sendBtn.disabled = true;
                    disconnectBtn.disabled = true;
                    disconnectWSBtn.disabled = true;
                    break;
                    
                case 'connecting':
                    statusEl.textContent = 'üîÑ Connecting...';
                    connectBtn.disabled = true;
                    disconnectWSBtn.disabled = true;
                    break;
            }
        }
        function generateNewRoom() {
            const signaling = new WebRTCTrackerSignaling('');
            const newHash = signaling.generateSimpleInfoHash();
            document.getElementById('infoHash').value = newHash;
        }

        async function connectToTracker() {
            const trackerUrl = document.getElementById('trackerUrl').value;
            updateStatus('connecting');
            
            signaling = new WebRTCTrackerSignaling(trackerUrl);
            
            // Set up event handlers
            signaling.onStatusChanged = updateStatus;
            signaling.onPeerConnected = (peerId) => {
                signaling.log('üéâ Peer connected: ' + peerId);
                document.getElementById('sendBtn').disabled = false;
            };
            signaling.onMessageReceived = (message, fromPeer) => {
                signaling.log('üí¨ Message: ' + message + (fromPeer ? ' from ' + fromPeer : ''));
            };
            
            // Display peer ID
            document.getElementById('peerIdDisplay').textContent = signaling.peerId;
            
            try {
                await signaling.connect();
            } catch (error) {
                updateStatus('disconnected');
                alert('Failed to connect: ' + error);
            }
        }

        function joinRoom() {
            const infoHash = document.getElementById('infoHash').value;
            if (!infoHash || infoHash.length !== 20) {
                alert('Please enter a valid 20-digit info hash');
                return;
            }
            signaling.announceToSwarm(infoHash);
        }

        function createOffer() {
            if (signaling) {
                signaling.createAndSendOffer();
            }
        }

        function sendMessage() {
            const message = document.getElementById('testMessage').value;
            if (signaling && message) {
                const sent = signaling.sendMessageToAll(message);
                if (sent === 0) {
                    alert('No connected peers to send message to');
                }
            }
        }

function checkConnections() {
    if (!signaling) {
        alert('Not connected to signaling service');
        return;
    }
    
    console.log('üîç Checking P2P connections...');
    
    // Log peer connections status
    console.log(`üìä Total peer connections: ${signaling.peerConnections.size}`);
    console.log(`üìä Active data channels: ${signaling.dataChannels.size}`);
    console.log(`üìä Connected peers: ${signaling.connectedPeers.size}`);
    
    // Check each peer connection
    signaling.peerConnections.forEach((peerConnection, peerId) => {
        console.log(`üîó Peer ${peerId}:`);
        console.log(`  - Connection State: ${peerConnection.connectionState}`);
        console.log(`  - ICE Connection State: ${peerConnection.iceConnectionState}`);
        console.log(`  - ICE Gathering State: ${peerConnection.iceGatheringState}`);
        console.log(`  - Signaling State: ${peerConnection.signalingState}`);
    });
    
    // Check data channels
    signaling.dataChannels.forEach((dataChannel, peerId) => {
        console.log(`üì° Data Channel ${peerId}:`);
        console.log(`  - Ready State: ${dataChannel.readyState}`);
        console.log(`  - Label: ${dataChannel.label}`);
    });
    
    // Display summary in alert
    const summary = `
Peer Connections: ${signaling.peerConnections.size}
Active Data Channels: ${signaling.dataChannels.size}
Connected Peers: ${signaling.connectedPeers.size}

Connected Peer IDs: ${Array.from(signaling.connectedPeers).join(', ') || 'None'}

Check console for detailed connection states.
    `;
    
    alert(summary.trim());
}


        function disconnect() {
            if (signaling) {
                signaling.disconnect();
                signaling = null;
            }
            updateStatus('disconnected');
        }

        function disconnectWebSocket() {
    if (signaling) {
        signaling.disconnectWebSocket();
        updateStatus('websocket-disconnected');
    } else {
        alert('No signaling connection available');
    }
}

        // Initialize UI
        updateStatus('disconnected');
        generateNewRoom();

        function updateSendButtonState() {
    const sendBtn = document.getElementById('sendBtn');
    
    if (signaling > 0) {
        sendBtn.disabled = false;
        sendBtn.textContent = `Send to ${signaling.connectedPeers.size} peer(s)`;
        sendBtn.style.backgroundColor = '#28a745';
    } else {
        sendBtn.disabled = true;
        sendBtn.textContent = 'Send Test Message';
        sendBtn.style.backgroundColor = '';
    }
}
function updateSendButtonStateByDataChannels() {
    const sendBtn = document.getElementById('sendBtn');
    
    if (!signaling) {
        sendBtn.disabled = true;
        sendBtn.classList.remove('force-enabled');
        sendBtn.textContent = 'Send Test Message';
        return;
    }
    
    // Count open data channels
    let openChannels = 0;
    signaling.dataChannels.forEach((dc) => {
        if (dc.readyState === 'open') {
            openChannels++;
        }
    });
    
    console.log(`üìä Open data channels: ${openChannels}`);
    
    if (openChannels > 0) {
        // ACTUALLY enable the button AND add CSS class to override disabled styles
        sendBtn.disabled = false;
        sendBtn.classList.add('force-enabled');
        sendBtn.textContent = `Send to ${openChannels} peer(s)`;
        console.log('‚úÖ Button enabled with CSS override');
    } else {
        sendBtn.disabled = true;
        sendBtn.classList.remove('force-enabled');
        sendBtn.textContent = 'Send Test Message';
        console.log('‚ùå Button disabled');
    }
}

    </script>
</body>
</html>